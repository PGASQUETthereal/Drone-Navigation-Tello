from djitellopy import Tello
import time
import math
import cv2
import threading

from numpy import hanning

# Dimensions de l'image
FRAME_WIDTH = 960
FRAME_HEIGHT = 720
CENTER_X = FRAME_WIDTH // 2
CENTER_Y = FRAME_HEIGHT // 2

# Seuils pour définir une zone où le drone ne bouge pas
TOLERANCE_X = 100
TOLERANCE_Y = 80

# Tentative de connexion au drone
try:
    drone = Tello()
    drone.connect()
    print(f"Battery Level: {drone.get_battery()}%")
    drone.streamon()
    drone_connected = True
except Exception as e:
    print("Drone non connecté :", e)


def send_commands_to_drone(face_x, face_y, face_w, face_h):
    """
    Envoie des commandes au drone pour suivre le visage détecté.
    """
    if not drone_connected:
        print("Drone non connecté")
        return

    # Calcul de la position du centre du visage
    face_center_x = face_x + face_w // 2
    face_center_y = face_y + face_h // 2

    # Calcul des écarts entre le centre du visage et le centre de l'image
    delta_x = face_center_x - CENTER_X
    delta_y = face_center_y - CENTER_Y

    # Commandes de mouvement
    if abs(delta_x) > TOLERANCE_X:
        if delta_x > 0:
            drone.move_right(20)  # Déplacer à droite
        else:
            drone.move_left(20)  # Déplacer à gauche

    if abs(delta_y) > TOLERANCE_Y:
        if delta_y > 0:
            drone.move_down(20)  # Descendre
        else:
            drone.move_up(20)  # Monter

    # Ajustement de la distance en fonction de la taille du visage
    if face_w < 100:  # Le visage est petit, avancer
        drone.move_forward(20)
    elif face_w > 150:  # Le visage est grand, reculer
        drone.move_back(20)




face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
drone.takeoff()


while True:
        # Capture d'une image du drone
        frame = drone.get_frame_read().frame
        frame = cv2.resize(frame, (FRAME_WIDTH, FRAME_HEIGHT))
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        # Convertir l'image en niveaux de gris pour la détection
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Détection des visages
        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

        # Dessiner des rectangles autour des visages détectés
        for (x, y, w, h) in faces:
            cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)
            threading.Thread(target=send_commands_to_drone, args=(x,y,w,h,), daemon=True).start()
        # Afficher l'image avec les rectangles
        cv2.imshow('Détection de Visage', frame)
        
        # Quitter le programme si 'q' est pressé
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break


# Atterrissage et arrêt du drone si connecté
if drone_connected:
    try:
        drone.land()
        drone.streamoff()
        drone.end()
    except Exception as e:
        print("Erreur lors de l'arrêt du drone :", e)

# Quitte Pygame et fenètre stream
cv2.destroyAllWindows()